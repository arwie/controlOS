' Copyright (c) 2016 Artur Wiebe <artur@4wiebe.de>
'
' Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
' associated documentation files (the "Software"), to deal in the Software without restriction, 
' including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
' and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
' subject to the following conditions:
'
' The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
' INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
' IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
' WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
' OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


common shared com_channelLog				as const long		= 1
common shared com_channelState				as const long		= 2
common shared com_channelFifo				as const long		= 3
common shared com_channelWebsocket			as const long		= 4

common shared com_receiveTimeout			as const long		= 0
common shared com_receiveMessage			as const long		= 1
common shared com_receiveConnect			as const long		= 10
common shared com_receiveDisconnect			as const long		= 11

common shared com_error						as error	"error in module mccom"		20800



import_c MCCOM_OPEN(byval as long, as long) as long
import_c MCCOM_RECEIVE(byval as long, byval as long, as long) as long
import_c MCCOM_SEND(byval as long, as long)
import_c MCCOM_SEND_SELF(byval as long, as long)
import_c MCCOM_RESET(byval as long)
import_c MCCOM_CLOSE(byval as long)
import_c MCCOM_CLOSE_ALL()
import_c MCCOM_CLEAR(as long)
import_c MCCOM_EMPTY(as long) as long
import_c MCCOM_STORE(byval as long, as long)
import_c MCCOM_RESTORE(as long)
import_c MCCOM_DELETE(as string)
import_c MCCOM_WITH(as string)
import_c MCCOM_EXTRACT(as string, as long)
import_c MCCOM_COMPACT(as string, as long)
import_c MCCOM_RECEIVE_STRING(as string, as long)
import_c MCCOM_SEND_STRING(as long) as string
import_c MCCOM_GET_LONG(as string, as long) as long
import_c MCCOM_GET_DOUBLE(as string, as long) as double
import_c MCCOM_GET_STRING(as string, as long) as string
import_c MCCOM_PUT_LONG(as string, byval as long, as long)
import_c MCCOM_PUT_DOUBLE(as string, byval as double, as long)
import_c MCCOM_PUT_STRING(as string, as string, as long)



public function com_open(byval channleType as long) as long
  dim err as long
  com_open = MCCOM_OPEN(channleType, err)
  if err then
    throw com_error
  end if
end function


public function com_receive(byval channelId as long, byval tout as long) as long
  dim err as long
  com_receive = MCCOM_RECEIVE(channelId, tout, err)
  if err then
    throw com_error
  end if
end function


public sub com_send(byval channelId as long)
  dim err as long
  MCCOM_SEND(channelId, err)
  if err then
    throw com_error
  end if
end sub


public sub com_sendSelf(byval channelId as long)
  dim err as long
  MCCOM_SEND_SELF(channelId, err)
  if err then
    throw com_error
  end if
end sub


public sub com_reset(byval channelId as long)
  MCCOM_RESET(channelId)
end sub


public sub com_close(byval channelId as long)
  MCCOM_CLOSE(channelId)
end sub


public sub com_closeAll
  MCCOM_CLOSE_ALL()
end sub


public sub com_clear
  dim err as long
  MCCOM_CLEAR(err)
  if err then
    throw com_error
  end if
end sub


public function com_empty as long
  dim err as long
  com_empty = MCCOM_EMPTY(err)
  if err then
    throw com_error
  end if
end function


public sub com_store
  dim err as long
  MCCOM_STORE(false, err)
  if err then
    throw com_error
  end if
end sub


public sub com_storeCopy
  dim err as long
  MCCOM_STORE(true, err)
  if err then
    throw com_error
  end if
end sub


public sub com_restore
  dim err as long
  MCCOM_RESTORE(err)
  if err then
    throw com_error
  end if
end sub


public sub com_delete(byval path as string)
  MCCOM_DELETE(path)
end sub


public sub com_with(byval path as string)
  MCCOM_WITH(path)
end sub


public sub com_extract(byval path as string)
  dim err as long
  MCCOM_EXTRACT(path, err)
  if err then
    throw com_error
  end if
end sub


public sub com_compact(byval path as string)
  dim err as long
  MCCOM_COMPACT(path, err)
  if err then
    throw com_error
  end if
end sub


public sub com_receiveString(byval str as string)
  dim err as long
  MCCOM_RECEIVE_STRING(str, err)
  if err then
    throw com_error
  end if
end sub


public function com_sendString as string
  dim err as long
  com_sendString = MCCOM_SEND_STRING(err)
  if err then
    throw com_error
  end if
end function


public function com_getLong(byval path as string) as long
  dim err as long
  com_getLong = MCCOM_GET_LONG(path, err)
  if err then
    throw com_error
  end if
end function


public function com_getDouble(byval path as string) as double
  dim err as long
  com_getDouble = MCCOM_GET_DOUBLE(path, err)
  if err then
    throw com_error
  end if
end function


public function com_getString(byval path as string) as string
  dim err as long
  com_getString = MCCOM_GET_STRING(path, err)
  if err then
    throw com_error
  end if
end function


public function com_getLocationXy(byval path as string) as location of xy
  com_getLocationXy = #{com_getDouble(path+".x"), com_getDouble(path+".y")} 
end function


public function com_getLocationXyzr(byval path as string) as location of xyzr
  com_getLocationXyzr = #{com_getDouble(path+".x"), com_getDouble(path+".y"), com_getDouble(path+".z"), com_getDouble(path+".r")} 
end function


public function com_getJointXyzr(byval path as string) as joint of xyzr
  com_getJointXyzr = {com_getDouble(path+".1"), com_getDouble(path+".2"), com_getDouble(path+".3"), com_getDouble(path+".4")} 
end function


public sub com_putLong(byval path as string, byval longValue as long)
  dim err as long
  MCCOM_PUT_LONG(path, longValue, err)
  if err then
    throw com_error
  end if
end sub


public sub com_putDouble(byval path as string, byval doubleValue as double)
  dim err as long
  MCCOM_PUT_DOUBLE(path, doubleValue, err)
  if err then
    throw com_error
  end if
end sub


public sub com_putString(byval path as string, byval stringValue as string)
  dim err as long
  MCCOM_PUT_STRING(path, stringValue, err)
  if err then
    throw com_error
  end if
end sub

public sub com_putStringRef(byval path as string, stringValue as string)
  dim err as long
  MCCOM_PUT_STRING(path, stringValue, err)
  if err then
    throw com_error
  end if
end sub


public sub com_putLocationXy(byval path as string, byval pos as location of xy)
  call com_putDouble(path+".x", pos{1})
  call com_putDouble(path+".y", pos{2})
end sub


public sub com_putLocationXyzr(byval path as string, byval pos as location of xyzr)
  call com_putDouble(path+".x", pos{1})
  call com_putDouble(path+".y", pos{2})
  call com_putDouble(path+".z", pos{3})
  call com_putDouble(path+".r", pos{4})
end sub


public sub com_putJointXyzr(byval path as string, byval jnt as joint of xyzr)
  call com_putDouble(path+".1", jnt{1})
  call com_putDouble(path+".2", jnt{2})
  call com_putDouble(path+".3", jnt{3})
  call com_putDouble(path+".4", jnt{4})
end sub
