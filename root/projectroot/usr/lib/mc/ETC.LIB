' Copyright (c) 2016 Artur Wiebe <artur@4wiebe.de>
'
' Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
' associated documentation files (the "Software"), to deal in the Software without restriction,
' including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
' and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
' subject to the following conditions:
'
' The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
' INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
' IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
' WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
' OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


common shared etc_busnumber as const long = 0
common shared etc_cycletime as const long = 4000	'{4000,2000,1000,500}[Âµs]

dim shared healthQueryIntervalMs as const long	= 60*60*1000
dim shared healthQueryTimeout as long



<?lib_systemError([19015])?>
	call etc_stopTrigger
end sub


<?lib_init()?>
	call logEthercat("init", false)

	call dropLong(EC_ETHERCAT_INIT)
	call sleepActive(<?=count(get('etc'))?> * 250)

<?
	foreach(get('etc') as $dev) {
		ll("'--------");
		switch ($dev['device']) {
			case 'cdhd':
				ll('call EC_REMAP_CDHD_DEFAULT_PDOS('.$dev['address'].')');
				break;
			case 'stepim':
				ll('call setupPdoMapping_stepim('.$dev['address'].')');
				break;
		}
	}
?>

	call dropLong(EC_RESCAN_SLAVES)
	call sleepActive(500)
	call dropLong(CHECK_TOPOLOGY)
	call EC_CREATE_MASTER

<?
	foreach(get('etc') as $dev) {
		ll("'--------");
		ll('call EC_SLAVE_ERROR_RESET('.$dev['address'].')');
		switch ($dev['device']) {
			case 'cdhd':
				ll('call EC_CDHD_SET_PDOS('.$dev['address'].', etc_busnumber, 0, CDHD_OPMODE_SYNC_POSITION)');
				ll('call EC_USE_SLAVE('.$dev['address'].', EC_SLAVES_INFO['.$dev['address'].']->vendor_id, EC_SLAVES_INFO['.$dev['address'].']->product_code, "ECAT_AXIS_SLAVE", true)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x6060, 0, 8,  CDHD_OPMODE_SYNC_POSITION)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x60C2, 1, 8,  etc_cycletime/100)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x60C2, 2, 8,  -4)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x60C0, 0, 16, 2)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x6040, 0, 16, 128)');
				break;
			case 'stepim':
				ll('call EC_CDHD_SET_PDOS('.$dev['address'].', etc_busnumber, 0, CDHD_OPMODE_SYNC_POSITION)');
				ll('call EC_USE_SLAVE('.$dev['address'].', EC_SLAVES_INFO['.$dev['address'].']->vendor_id, EC_SLAVES_INFO['.$dev['address'].']->product_code, "ECAT_AXIS_SLAVE", true)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x6060, 0, 8,  CDHD_OPMODE_SYNC_POSITION)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x60C2, 1, 8,  etc_cycletime/100)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x60C2, 2, 8,  -4)');
				ll('call etc_sdoWrite('.$dev['address'].', 0x6040, 0, 16, 128)');
				break;
			default:
				ll('call EC_USE_SLAVE('.$dev['address'].', EC_SLAVES_INFO['.$dev['address'].']->vendor_id, EC_SLAVES_INFO['.$dev['address'].']->product_code, "ECAT_IOMODULE_SLAVE", true)');
				break;
		}
		foreach (array_merge($dev['readBit'], $dev['writeBit']) as $bit)
			ll('call EC_ASSOCIATE_PDO_TO_SYS_DIO('.$dev['address'].', 0x'.dechex($bit['index']).', '.$bit['subindex'].', '.$bit['dio'].', '.$bit['size'].', '.$bit['offset'].')');
	}
?>
end sub


<?lib_start()?>
	call EC_SET_BUS_CYCLETIME(etc_cycletime)
	call dropLong(EC_SET_NEW_STATIC_DISTANCE(300))
	
	call EC_STARTMASTER
	
	healthQueryTimeout = system.clock + healthQueryIntervalMs
end sub


<?lib_prgLoop()?>
	if system.clock > healthQueryTimeout then
		healthQueryTimeout = system.clock + healthQueryIntervalMs
		call logEthercat("health", true)
	end if
	call sleepActive(5000)
end sub


<?lib_prgStop()?>
	call dropString(sh("ethercat rescan"))
	sleep 3000
	call logEthercat("stop", false)
end sub


sub logEthercat(byval what_ as string, byval regs_ as long)
	call logLibInfo("ethercat "+what_)
	call log_putMessageId("af06a2c1696f46b18b948283b249a04e")
	call com_putString("/master", sh("ethercat master"))
	call com_putString("/slaves", sh("ethercat slaves"))
	call com_putString("/slaves_info", sh("ethercat -v slaves"))
	if regs_ then
<?foreach(get('etc') as $dev) {?>
		try
			call com_putString("/regs_<?=$dev['address']?>", EC_SLAVE_ERROR_REGS(<?=$dev['address']?>))
		catch else
		end try
<?}?>
	end if
	call logSend
end sub



public sub etc_write(byval slave_ as long, byval index_ as long, byval subindex_ as long, byval size_ as long, byval value_ as long)
	if EC_IS_PDO(slave_, index_, subindex_) then
		call etc_pdoWrite(slave_, index_, subindex_, value_)
	else
		call etc_sdoWrite(slave_, index_, subindex_, size_, value_)
	end if
end sub

public function etc_read(byval slave_ as long, byval index_ as long, byval subindex_ as long) as long
	if EC_IS_PDO(slave_, index_, subindex_) then
		etc_read = etc_pdoRead(slave_, index_, subindex_)
	else
		etc_read = etc_sdoRead(slave_, index_, subindex_)
	end if
end function



<?$etc_xdoReadWriteBody = function($cmd, $valueType=false) {
	ll('try');
	lll($cmd);
	ll('catch else');
	lll('call logLibError(scope+": "+error)');
	lll('call com_putLong("/error", errornumber)');
	lll('call log_putCodeFunc(scope)');
	lll('call com_putLong("/slave", slave_)');
	lll('call com_putString("/index", hex$(index_)+"h")');
	lll('call com_putLong("/subindex", subindex_)');
	if ($valueType) lll('call com_put'.ucfirst($valueType).'("/value", value_)');
	lll('call logSend');
	ll('finally');
	lll('healthQueryTimeout = 0');
	lll('throw');
	ll('end try');
}?>


public sub etc_pdoWrite(byval slave_ as long, byval index_ as long, byval subindex_ as long, byval value_ as long)
<?	$etc_xdoReadWriteBody('call EC_PDO_WRITE(slave_, index_, subindex_, value_)', 'long')?>
end sub

public function etc_pdoRead(byval slave_ as long, byval index_ as long, byval subindex_ as long) as long
<?	$etc_xdoReadWriteBody('etc_pdoRead = EC_PDO_READ(slave_, index_, subindex_)')?>
end function


public sub etc_sdoWrite(byval slave_ as long, byval index_ as long, byval subindex_ as long, byval size_ as long, byval value_ as long)
<?	$etc_xdoReadWriteBody('call EC_SDO_WRITE(slave_, index_, subindex_, size_, value_)', 'long')?>
end sub

public function etc_sdoRead(byval slave_ as long, byval index_ as long, byval subindex_ as long) as long
<?	$etc_xdoReadWriteBody('etc_sdoRead = EC_SDO_READ(slave_, index_, subindex_)')?>
end function


public function etc_readString(byval slave_ as long, byval index_ as long, byval subindex_ as long) as string
	dim strLen_ as long
<?	$etc_xdoReadWriteBody('etc_readString = EC_SDO_READ_STRING(slave_, index_, subindex_, strLen_)')?>
end function



sub setupPdoMapping_stepim(byval address_ as long)
	call etc_sdoWrite(address_, 0x1C12, 0, 8, 0)
	call etc_sdoWrite(address_, 0x1C12, 1, 16, 0x1600)
	call etc_sdoWrite(address_, 0x1C12, 0, 8, 1)
	call etc_sdoWrite(address_, 0x1600, 0, 8, 0)
	call etc_sdoWrite(address_, 0x1600, 1, 32, 0x60400010)
	call etc_sdoWrite(address_, 0x1600, 2, 32, 0x607A0020)
	call etc_sdoWrite(address_, 0x1600, 3, 32, 0x60FE0120)
	call etc_sdoWrite(address_, 0x1600, 0, 8, 3)
	call etc_sdoWrite(address_, 0x1C13, 0, 8, 0)
	call etc_sdoWrite(address_, 0x1C13, 1, 16, 0x1A00)
	call etc_sdoWrite(address_, 0x1C13, 0, 8, 1)
	call etc_sdoWrite(address_, 0x1A00, 0, 8, 0)
	call etc_sdoWrite(address_, 0x1A00, 1, 32, 0x60410010)
	call etc_sdoWrite(address_, 0x1A00, 2, 32, 0x60640020)
	call etc_sdoWrite(address_, 0x1A00, 3, 32, 0x60FD0020)
	call etc_sdoWrite(address_, 0x1A00, 0, 8, 3)
end sub
